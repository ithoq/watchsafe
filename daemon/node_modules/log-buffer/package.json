{
  "name": "log-buffer",
  "description": "Buffer calls to console.log, console.warn, etc. for high performance logging",
  "version": "0.0.3",
  "author": {
    "name": "Dave Eddy",
    "email": "dave@daveeddy.com",
    "url": "http://www.daveeddy.com"
  },
  "contributors": [],
  "repository": {
    "type": "git",
    "url": "git://github.com/bahamas10/node-log-buffer.git"
  },
  "scripts": {
    "test": "for f in tests/*; do echo \"$f\"; node \"$f\"; done; echo 'passed!'; exit 0"
  },
  "dependencies": {},
  "devDependencies": {},
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "keywords": [
    "console",
    "console.log",
    "log",
    "logger",
    "timestamp",
    "buffer"
  ],
  "readme": "log-buffer\n==========\n\nBuffer calls to `console.log`, `console.warn`, etc. for high performance logging\n\nDescription\n-----------\n\nCalls to `console.log`, `console.error`, etc. are synchronous, and as such,\nwill block the event loop while the data is being written to a file, terminal,\nsocket, pipe, etc.\n\nThis module provides a seamless, drop-in buffer for all calls to these\nfunctions, and flushes them when the buffers exceed a certain size (8k by\ndefault).\n\nSee [Known Issues](#known-issues) for timing concerns with this module.\n\nExample\n-------\n\n``` js\nrequire('log-buffer');\nconsole.log('Hello'); // buffered\nconsole.log('world'); // buffered\n// flushed at exit or 8k of data\n```\n\nEven though there are 2 calls to `console.log`, this example only writes to a\nfile descriptor once.\n\nCustomization\n-------------\n\nYou can specify an alternative buffer size to use for automatic flushing like\nthis:\n\n``` js\nrequire('log-buffer')(4096); // buffer will flush at 4k\n```\n\nYou can specify a function or string to prefix all log statements\n\n```js\nrequire('log-buffer')(4096, 'MyLog: ');\n```\n\nAll log statements will be prepended `MyLog: ` when flushed.\n\n``` js\nrequire('log-buffer')(4096, function() { return new Date().toISOString() + ': '; });\n```\n\nAll log statements will be prepended by `2013-04-27T04:37:24.703Z: ` for example\n\nThis module also exposes the `flush` function used to flush all buffers, so\nif you would like you can manually invoke a flush.\n\n``` js\nvar logbuffer = require('log-buffer');\nconsole.log('hello'); // buffered\nconsole.log('world'); // buffered\nlogbuffer.flush(); // flushed\n```\n\nAlso, you can specify an interval to automatically flush all buffers so logs\ndon't get held in memory indefinitely.\n\n``` js\nvar logbuffer = require('log-buffer');\nsetInterval(function() {\n  logbuffer.flush();\n}, 5000); // flush every 5 seconds\n```\n\nThis will flush automatically at 8k of data as well as every 5 seconds.\n\n`console._LOG_BUFFER` is also defined when this module is included.\n\nBenchmark\n---------\n\n### Speed\n\nTested on a Joyent smartmachine in the Joyent Public Cloud\n(joyent_20120912T055050Z)\n\nCounting to a million, logging each iteration, piping to dd, without buffering\n\n    $ time node benchmark/count.js | dd > /dev/null\n    0+982421 records in\n    13454+1 records out\n    6888890 bytes (6.9 MB) copied, 19.0066 s, 362 kB/s\n\n    real    0m19.111s\n    user    0m16.409s\n    sys     0m6.546s\n\nCounting to a million, logging each iteration, piping to dd, with buffering (8k)\n\n    $ time node benchmark/bcount.js | dd > /dev/null\n    13446+841 records in\n    13454+1 records out\n    6888890 bytes (6.9 MB) copied, 3.46552 s, 2.0 MB/s\n\n    real    0m3.495s\n    user    0m3.390s\n    sys     0m0.136s\n\n\nA **5.5x** increase in speed with log buffering\n\n### syscalls\n\nUsing DTrace(1M) we can see how many times the system was asked to write\n\nIn the examples below, the output is redirected to `/dev/null` so we don't\nget a line printed for each iteration of the loop.  DTrace is then told to\noutput to stderr so its data doesn't get sent to `/dev/null` as well.\n\nCounting to a million, logging each iteration to `/dev/null`, without buffering\n\n    $ dtrace -n 'syscall::write*:entry /pid == $target/ { @ = count(); }' -c 'node count.js' -o /dev/stderr > /dev/null\n    dtrace: description 'syscall::write*:entry ' matched 2 probes\n    dtrace: pid 33117 has exited\n\n              1000000\n\nCounting to a million, logging each iteration to `/dev/null`, with buffering (8k)\n\n    $ dtrace -n 'syscall::write*:entry /pid == $target/ { @ = count(); }' -c 'node bcount.js' -o /dev/stderr > /dev/null\n    dtrace: description 'syscall::write*:entry ' matched 2 probes\n    dtrace: pid 31513 has exited\n\n                  841\n\n1,000,000 write(2) syscalls are fired without buffering, whereas only 841 are fired\nwhen the output is buffered.\n\nA **1,189x** decrease in the number of syscalls; **1** buffered syscall for\nevery **1,189** unbuffered syscalls.\n\nInstall\n------\n\n    npm install log-buffer\n\nTests\n-----\n\n    npm test\n\nKnown Issues\n------------\n\n- All buffers are flushed when `flush` is called (whether automatically\nor manually).  Because of this, calls to different `console` family functions\nmay return out of order.\n\nExample:\n\n``` js\nrequire('log-buffer');\nconsole.log(1);\nconsole.error(2);\nconsole.log(3);\n```\n\nyields\n\n    1\n    3\n    2\n\n`1` and `3` are both written to stdout and `2` is written stderr.\nThe priority order in flushing  is `['warn', 'log', 'error', 'info']`\n\nLicense\n-------\n\nMIT Licensed\n",
  "_id": "log-buffer@0.0.3",
  "dist": {
    "shasum": "0dc0e889e841102b664af4943618fb4a39c4cb09"
  },
  "_from": "log-buffer"
}
